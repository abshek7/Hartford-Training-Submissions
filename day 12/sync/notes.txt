Why the Page Freezes: Synchronous JavaScript and the Main Thread

When you click “Generate primes”, the web page becomes completely unresponsive. You can’t type in the text box, click buttons, or interact with the page in any way. This behavior is not a bug—it is a direct consequence of how synchronous JavaScript works in the browser.

What phenomenon is happening?

JavaScript in the browser runs on a single main thread. This thread is responsible for:

- Executing JavaScript code
- Handling user input (keyboard, mouse, touch)
- Updating and repainting the UI

In this example, the generatePrimes() function runs a long, CPU-intensive loop that continuously checks random numbers for primality. While this loop is running, the main thread is fully occupied. Because the thread is busy, the browser cannot:

- Process keyboard events (typing doesn’t appear)
- Handle mouse clicks
- Repaint the screen
- Run any other JavaScript

This situation is called main thread blocking.

Why synchronous programming causes this problem

Synchronous code executes from top to bottom without interruption. Once a synchronous function starts running, JavaScript will not stop it until it finishes.

In this line:

const primes = generatePrimes(quota.value);

the browser must wait for generatePrimes() to finish completely before it can do anything else. If the function takes several seconds, the entire page freezes for that time.

This is why synchronous programming is dangerous for long-running tasks in user interfaces: it blocks everything.

Why this feels especially bad in the browser

Unlike server-side programs, browsers are interactive. Users expect to:

- Type while something is loading
- Scroll while calculations run
- Click “Cancel” if something takes too long

Synchronous code breaks these expectations. The UI becomes frozen, which feels like the page has crashed—even though it technically hasn’t.

More real-world examples of this problem

1. Large loops
for (let i = 0; i < 1_000_000_000; i++) {
  // heavy calculation
}
The page will freeze until the loop completes.

2. Sorting huge arrays
bigArray.sort((a, b) => expensiveComparison(a, b));
Sorting a very large dataset synchronously can lock up the UI for seconds.

3. Image or data processing
processEveryPixel(imageData);
Pixel-by-pixel image manipulation on the main thread causes visible freezing.

4. JSON parsing of massive data
const data = JSON.parse(veryLargeJSONString);
Parsing megabytes of JSON synchronously can block rendering and input.

5. Poorly written recursive functions
function deepRecursion(n) {
  if (n === 0) return;
  deepRecursion(n - 1);
}
deepRecursion(1_000_000);
This can freeze or crash the page entirely.

Why async/await exists and their significance

JavaScript introduced async/await to simplify working with asynchronous operations, such as:

- Network requests (fetching data)
- Timers (setTimeout, setInterval)
- File reading in Node.js
- Any Promise-based API

Async/await allows you to pause the execution of a function without blocking the main thread. While the function “waits,” the browser can continue responding to:

- Keyboard and mouse input
- Page rendering
- Other scripts

This is a key improvement over synchronous code: the UI remains responsive even while waiting for slow operations to complete.

How async/await improves responsiveness

Example 1: Fetching data without blocking

async function fetchUser() {
  const response = await fetch("https://api.example.com/user");
  const data = await response.json();
  console.log(data);
}
fetchUser();

Example 2: Using a timer to avoid freezing during heavy loops

async function processInChunks(items) {
  for (let i = 0; i < items.length; i++) {
    process(items[i]);

    // Yield control every 100 items
    if (i % 100 === 0) {
      await new Promise(requestAnimationFrame);
    }
  }
}

Example 3: Combining async/await with fetch and timers


async function loadDataAndAnimate() {
  await fetch("https://api.example.com/large-data.json");
  console.log("Data loaded!");

  for (let i = 0; i < 1000; i++) {
    animateFrame(i);
    await new Promise(requestAnimationFrame); // keeps animation smooth
  }
}

